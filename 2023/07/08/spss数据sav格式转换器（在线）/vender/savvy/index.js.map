{"version":3,"file":"index.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://savvy/webpack/universalModuleDefinition","webpack://savvy/./dataset.ts","webpack://savvy/webpack/bootstrap","webpack://savvy/./index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"savvy\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"savvy\"] = factory();\n\telse\n\t\troot[\"savvy\"] = factory();\n})(self, () => {\nreturn ","\"use strict\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Savvy = void 0;\nvar Column = /*#__PURE__*/function () {\n  function Column(parent, key, nulls) {\n    _classCallCheck(this, Column);\n    this.parent = parent;\n    this.key = key;\n    this.nulls = nulls;\n  }\n  _createClass(Column, [{\n    key: \"raw\",\n    value: function raw() {\n      var _this = this;\n      return new Array(this.parent.n).fill(0).map(function (_, idx) {\n        return _this.parent.cell(idx, _this.key, false);\n      });\n    }\n  }, {\n    key: \"values\",\n    get: function get() {\n      var _this2 = this;\n      return this.raw().map(function (value) {\n        return _this2.cast(value);\n      });\n    }\n  }, {\n    key: \"exists\",\n    value: function exists() {\n      return true;\n    }\n  }, {\n    key: \"name\",\n    get: function get() {\n      var _a;\n      return (_a = this.parent.names.get(this.key)) !== null && _a !== void 0 ? _a : this.key;\n    }\n  }, {\n    key: \"label\",\n    get: function get() {\n      var _a;\n      return (_a = this.parent.labels.get(this.key)) !== null && _a !== void 0 ? _a : '';\n    }\n  }, {\n    key: \"missing\",\n    get: function get() {\n      return new Set(this.nulls);\n    },\n    set: function set(nulls) {\n      this.nulls = new Set(nulls);\n    }\n  }, {\n    key: \"ismissing\",\n    value: function ismissing(value) {\n      return this.nulls.has(value);\n    }\n  }]);\n  return Column;\n}();\nvar NullColumn = /*#__PURE__*/function (_Column) {\n  _inherits(NullColumn, _Column);\n  var _super = _createSuper(NullColumn);\n  function NullColumn(parent) {\n    _classCallCheck(this, NullColumn);\n    return _super.call(this, parent, '<NULL>', new Set());\n  }\n  _createClass(NullColumn, [{\n    key: \"exists\",\n    value: function exists() {\n      return false;\n    }\n  }, {\n    key: \"raw\",\n    value: function raw() {\n      return new Array(this.parent.n).fill(null);\n    }\n  }, {\n    key: \"values\",\n    get: function get() {\n      return new Array(this.parent.n).fill(null);\n    }\n  }, {\n    key: \"cast\",\n    value: function cast(value) {\n      return null;\n    }\n  }, {\n    key: \"measure\",\n    get: function get() {\n      return 'null';\n    }\n  }, {\n    key: \"levels\",\n    get: function get() {\n      return new Map();\n    }\n  }]);\n  return NullColumn;\n}(Column);\nvar StrColumn = /*#__PURE__*/function (_Column2) {\n  _inherits(StrColumn, _Column2);\n  var _super2 = _createSuper(StrColumn);\n  function StrColumn() {\n    _classCallCheck(this, StrColumn);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(StrColumn, [{\n    key: \"cast\",\n    value: function cast(value) {\n      return this.ismissing(value) ? null : value;\n    }\n  }, {\n    key: \"measure\",\n    get: function get() {\n      return 'nominal';\n    }\n  }, {\n    key: \"levels\",\n    get: function get() {\n      return new Map();\n    }\n  }]);\n  return StrColumn;\n}(Column);\nvar FacColumn = /*#__PURE__*/function (_Column3) {\n  _inherits(FacColumn, _Column3);\n  var _super3 = _createSuper(FacColumn);\n  function FacColumn(parent, key, levels, nulls, type) {\n    var _this3;\n    _classCallCheck(this, FacColumn);\n    _this3 = _super3.call(this, parent, key, nulls);\n    _this3._levels = levels;\n    _this3.type = type;\n    return _this3;\n  }\n  _createClass(FacColumn, [{\n    key: \"cast\",\n    value: function cast(value) {\n      return this.ismissing(value) ? null : this._levels.get(value);\n    }\n  }, {\n    key: \"measure\",\n    get: function get() {\n      switch (this.type) {\n        case 3:\n          return 'scale';\n        case 2:\n          return 'ordinal';\n        default:\n          return 'nominal';\n      }\n    }\n  }, {\n    key: \"levels\",\n    get: function get() {\n      return new Map(_toConsumableArray(this._levels));\n    },\n    set: function set(levels) {\n      var _this4 = this;\n      levels.forEach(function (value, key) {\n        if (_this4._levels.has(key)) {\n          _this4._levels.set(key, value);\n        }\n      });\n    }\n  }]);\n  return FacColumn;\n}(Column);\nvar NumColumn = /*#__PURE__*/function (_Column4) {\n  _inherits(NumColumn, _Column4);\n  var _super4 = _createSuper(NumColumn);\n  function NumColumn(parent, key, nulls, nullrange, type) {\n    var _this5;\n    _classCallCheck(this, NumColumn);\n    _this5 = _super4.call(this, parent, key, nulls);\n    _this5.nullrange = nullrange;\n    _this5.type = type;\n    return _this5;\n  }\n  _createClass(NumColumn, [{\n    key: \"cast\",\n    value: function cast(value) {\n      return this.ismissing(value) ? null : value;\n    }\n  }, {\n    key: \"measure\",\n    get: function get() {\n      switch (this.type) {\n        case 2:\n          return 'ordinal';\n        default:\n          return 'scale';\n      }\n    }\n  }, {\n    key: \"levels\",\n    get: function get() {\n      return new Map();\n    }\n  }, {\n    key: \"ismissing\",\n    value: function ismissing(value) {\n      return this.nulls.has(value) || value > this.nullrange[0] && value < this.nullrange[1];\n    }\n  }]);\n  return NumColumn;\n}(Column);\nvar View = /*#__PURE__*/function () {\n  function View(parent, indices, keys) {\n    _classCallCheck(this, View);\n    var _a, _b;\n    this.parent = parent;\n    this.indices = (_a = indices === null || indices === void 0 ? void 0 : indices.slice()) !== null && _a !== void 0 ? _a : new Array(parent.n).fill(0).map(function (_, idx) {\n      return idx;\n    });\n    this._keys = (_b = keys === null || keys === void 0 ? void 0 : keys.slice()) !== null && _b !== void 0 ? _b : Array.from(parent.names.keys());\n  }\n  _createClass(View, [{\n    key: \"n\",\n    get: function get() {\n      return this.indices.length;\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return _toConsumableArray(this._keys);\n    }\n  }, {\n    key: \"names\",\n    get: function get() {\n      var names = this.parent.names;\n      return new Map(this.keys.map(function (key) {\n        var _a;\n        return [key, (_a = names.get(key)) !== null && _a !== void 0 ? _a : key];\n      }));\n    }\n  }, {\n    key: \"labels\",\n    get: function get() {\n      var labels = this.parent.labels;\n      return new Map(this.keys.map(function (key) {\n        var _a;\n        return [key, (_a = labels.get(key)) !== null && _a !== void 0 ? _a : ''];\n      }));\n    }\n  }, {\n    key: \"row\",\n    value: function row(index) {\n      return this.parent.row(this.indices[index]);\n    }\n  }, {\n    key: \"col\",\n    value: function col(key) {\n      var all = this.parent.col(key);\n      return this.indices.map(function (index) {\n        return all[index];\n      });\n    }\n  }, {\n    key: \"cell\",\n    value: function cell(index, key) {\n      return this.parent.cell(this.indices[index], key);\n    }\n  }, {\n    key: \"view\",\n    value: function view(indices, keys) {\n      var _this6 = this;\n      return new View(this.parent, indices.map(function (index) {\n        return _this6.indices[index];\n      }), keys);\n    }\n  }]);\n  return View;\n}();\n/**\r\n * A DataSet subclass that can be constructed from a {@link Parsed} object\r\n */\nvar Savvy = /*#__PURE__*/function () {\n  /**\r\n   *\r\n   * @param parsed a {@link Parsed} object generated with a {@link SavParser}\r\n   */\n  function Savvy(parsed) {\n    _classCallCheck(this, Savvy);\n    var _a;\n    this.cases = parsed.meta.cases;\n    this._names = parsed.internal.names;\n    this.data = parsed.rows;\n    var levels = new Map(parsed.headers.map(function (header) {\n      return [header.name, new Map()];\n    }));\n    var cursor = 0;\n    var indexmap = new Map(parsed.headers.map(function (header, idx) {\n      var offset = cursor + 1;\n      cursor++;\n      cursor += header.trailers;\n      return [offset, idx];\n    }));\n    parsed.internal.levels.forEach(function (entry) {\n      return entry.indices.forEach(function (index) {\n        return indexmap.has(index) && levels.set(parsed.headers[indexmap.get(index)].name, entry.map);\n      });\n    });\n    this.fields = new Map();\n    this.overflows = new Map();\n    this._labels = new Map();\n    var j = 0;\n    for (var i = 0; i < parsed.headers.length; i++) {\n      j = i;\n      var header = parsed.headers[i];\n      this._labels.set(header.name, header.label);\n      if (header.code) {\n        var overflow = [];\n        if (parsed.internal.longs.has(header.name)) {\n          var segs = Math.floor(parsed.internal.longs.get(header.name) / 252);\n          while (segs > 0) {\n            segs -= 1;\n            overflow.push(parsed.headers[++i].name);\n          }\n        }\n        this.overflows.set(header.name, overflow);\n        this.fields.set(header.name, new StrColumn(this, header.name, new Set(header.missing.strings)));\n      } else {\n        if ((_a = levels.get(header.name)) === null || _a === void 0 ? void 0 : _a.size) {\n          this.fields.set(header.name, new FacColumn(this, header.name, levels.get(header.name), new Set(header.missing.codes), parsed.internal.display[j].type));\n        } else {\n          this.fields.set(header.name, new NumColumn(this, header.name, new Set(header.missing.codes), header.missing.range, parsed.internal.display[j].type));\n        }\n      }\n    }\n  }\n  _createClass(Savvy, [{\n    key: \"n\",\n    get: function get() {\n      return this.cases;\n    }\n  }, {\n    key: \"keys\",\n    get: function get() {\n      return Array.from(this.fields.keys());\n    }\n    /**\r\n     * A map of of unique column keys to variable names\r\n     */\n  }, {\n    key: \"names\",\n    get: function get() {\n      return new Map(_toConsumableArray(this._names));\n    },\n    set: function set(names) {\n      var _this7 = this;\n      names.forEach(function (value, key) {\n        if (_this7._names.has(key)) {\n          _this7._names.set(key, value);\n        }\n      });\n    }\n    /**\r\n     * A map of of unique column keys to longer labels\r\n     */\n  }, {\n    key: \"labels\",\n    get: function get() {\n      return new Map(_toConsumableArray(this._labels));\n    },\n    set: function set(labels) {\n      var _this8 = this;\n      labels.forEach(function (value, key) {\n        if (_this8._labels.has(key)) {\n          _this8._labels.set(key, value);\n        }\n      });\n    }\n  }, {\n    key: \"row\",\n    value: function row(index) {\n      var _this9 = this;\n      var cast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var row = new Map();\n      this.keys.forEach(function (key) {\n        return row.set(key, _this9.cell(index, key, cast));\n      });\n      return row;\n    }\n  }, {\n    key: \"field\",\n    value: function field(key) {\n      var _a;\n      return (_a = this.fields.get(key)) !== null && _a !== void 0 ? _a : new NullColumn(this);\n    }\n  }, {\n    key: \"col\",\n    value: function col(key) {\n      var _this10 = this;\n      var cast = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      return new Array(this.n).fill(0).map(function (_, idx) {\n        return _this10.cell(idx, key, cast);\n      });\n    }\n  }, {\n    key: \"cell\",\n    value: function cell(index, key) {\n      var cast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      var _a;\n      var field = this.field(key);\n      var row = this.data[index];\n      var raw = row.get(key);\n      (_a = this.overflows.get(key)) === null || _a === void 0 ? void 0 : _a.forEach(function (overflow) {\n        var _a;\n        raw = raw.toString() + ((_a = row.get(overflow)) !== null && _a !== void 0 ? _a : '');\n      });\n      return cast ? field.cast(raw) : raw;\n    }\n  }, {\n    key: \"view\",\n    value: function view(indices, fields) {\n      return new View(this, indices, fields);\n    }\n  }]);\n  return Savvy;\n}();\nexports.Savvy = Savvy;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Savvy = exports.SavParser = exports.Feeder = void 0;\n/**\r\n * An object that stores an {@link ArrayBuffer} and returns subsequent portions on demand\r\n */\nvar Feeder = /*#__PURE__*/function () {\n  /**\r\n   *\r\n   * @param buffer An {@link ArrayBuffer} that will be fed out by the object\r\n   */\n  function Feeder(buffer) {\n    _classCallCheck(this, Feeder);\n    this.buffer = buffer;\n    this.cursor = 0;\n  }\n  /**\r\n   * Jump the cursor to a position in the buffer.\r\n   * @param position the position in the {@link ArrayBuffer} to jump to\r\n   */\n  _createClass(Feeder, [{\n    key: \"jump\",\n    value: function jump(position) {\n      if (position < 0 || position > this.buffer.byteLength) {\n        throw new Error('Jump to out-of-bounds position');\n      }\n      this.cursor = position;\n    }\n    /**\r\n     * Get the next chunk of the ArrayBuffer from the current cursor position\r\n     * and move the cursor.\r\n     * @param size the number of bytes to read from the {@link ArrayBuffer}\r\n     * @returns an {@link ArrayBuffer} of the requested `size` from the cursor position\r\n     */\n  }, {\n    key: \"next\",\n    value: function next(size) {\n      if (!this.buffer || this.cursor + size > this.buffer.byteLength) {\n        throw new Error('Unexpected End of File');\n      } else {\n        this.cursor += size;\n        return this.buffer.slice(this.cursor - size, this.cursor);\n      }\n    }\n    /**\r\n     * Get the current position of the cursor\r\n     * @returns the current cursor position as a number\r\n     */\n  }, {\n    key: \"position\",\n    value: function position() {\n      return this.cursor;\n    }\n    /**\r\n     * Check whether the {@link ArrayBuffer} has been exhausted\r\n     * @returns a boolean, whether the {@link ArrayBuffer} is exhausted\r\n     */\n  }, {\n    key: \"done\",\n    value: function done() {\n      return this.cursor === this.buffer.byteLength;\n    }\n  }]);\n  return Feeder;\n}();\nexports.Feeder = Feeder;\nvar DataReader = /*#__PURE__*/function () {\n  function DataReader(schema, feeder) {\n    var log = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    _classCallCheck(this, DataReader);\n    this.feeder = feeder;\n    this.position = feeder.position();\n    this.cursor = 8;\n    this.schema = schema;\n    this.decoder = new TextDecoder();\n    this.log = log;\n  }\n  _createClass(DataReader, [{\n    key: \"compressedCodes\",\n    value: function compressedCodes() {\n      var instruction;\n      do {\n        if (this.cursor > 7) {\n          this.instructions = new DataView(this.feeder.next(8));\n          this.cursor = 0;\n        }\n        instruction = this.instructions.getUint8(this.cursor++);\n      } while (instruction === 0);\n      return instruction;\n    }\n  }, {\n    key: \"uncompressedNumber\",\n    value: function uncompressedNumber() {\n      return new DataView(this.feeder.next(8)).getFloat64(0, this.schema.internal.integer.endianness === 2);\n    }\n  }, {\n    key: \"uncompressedString\",\n    value: function uncompressedString(length) {\n      var pieces = [];\n      do {\n        pieces.concat(this.decoder.decode(this.feeder.next(8)));\n      } while (--length);\n      return pieces.join('');\n    }\n  }, {\n    key: \"compressedNumber\",\n    value: function compressedNumber() {\n      var code = this.compressedCodes();\n      switch (code) {\n        case 252:\n          throw new Error('Unexpected end of records.');\n        case 253:\n          return new DataView(this.feeder.next(8)).getFloat64(0, true);\n        case 254:\n          throw new Error('Cell code type mismatch');\n        case 255:\n          return null;\n        default:\n          return code - this.schema.meta.bias;\n      }\n    }\n  }, {\n    key: \"compressedString\",\n    value: function compressedString(length) {\n      var pieces = [];\n      do {\n        var code = this.compressedCodes();\n        switch (code) {\n          case 252:\n            throw new Error('Unexpected end of records.');\n          case 253:\n            pieces.push(this.decoder.decode(this.feeder.next(8)));\n            break;\n          case 254:\n            pieces.push('');\n            break;\n          case 255:\n            return null;\n          default:\n            throw new Error('Default code not supported for strings.');\n        }\n      } while (--length);\n      return pieces.join('');\n    }\n  }, {\n    key: \"readNumber\",\n    value: function readNumber() {\n      if (this.schema.meta.compression) {\n        return this.compressedNumber();\n      } else {\n        return this.uncompressedNumber();\n      }\n    }\n  }, {\n    key: \"readString\",\n    value: function readString(length) {\n      if (this.schema.meta.compression) {\n        return this.compressedString(length);\n      } else {\n        return this.uncompressedString(length);\n      }\n    }\n  }, {\n    key: \"readCell\",\n    value: function readCell(header) {\n      this.log.push('Cell: ' + header.name);\n      if (header.code) {\n        return this.readString(Math.ceil(header.code / 8));\n      } else {\n        return this.readNumber();\n      }\n    }\n  }, {\n    key: \"readRow\",\n    value: function readRow() {\n      var _this = this;\n      return new Map(this.schema.headers.map(function (header) {\n        return [header.name, _this.readCell(header)];\n      }));\n    }\n  }, {\n    key: \"read\",\n    value: function read() {\n      var _this2 = this;\n      this.feeder.jump(this.schema.internal.finished);\n      var readArray = new Array(this.schema.meta.cases).fill(0).map(function (_, idx) {\n        _this2.log.push('Row: ' + idx);\n        return _this2.readRow();\n      });\n      this.feeder.jump(this.position);\n      return readArray;\n    }\n  }]);\n  return DataReader;\n}();\n/**\r\n * A parser for .sav files\r\n */\nvar SavParser = /*#__PURE__*/function () {\n  /**\r\n   * Create a new parser\r\n   * @param log a string array that will be populated by parse calls\r\n   */\n  function SavParser() {\n    var log = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    _classCallCheck(this, SavParser);\n    this.decoder = new TextDecoder();\n    this.log = log;\n  }\n  _createClass(SavParser, [{\n    key: \"readFieldLabel\",\n    value: function readFieldLabel(feeder) {\n      var length = new DataView(feeder.next(4)).getInt32(0, true);\n      if (length % 4) {\n        length = length + (4 - length % 4);\n      }\n      return this.decoder.decode(feeder.next(length)).trim();\n    }\n  }, {\n    key: \"readFieldMissingCodes\",\n    value: function readFieldMissingCodes(view, count) {\n      var readArray = new Array(count).fill(0);\n      return readArray.map(function (_, idx) {\n        return view.getFloat64(8 * idx);\n      });\n    }\n  }, {\n    key: \"readFieldMissingStrings\",\n    value: function readFieldMissingStrings(chunk, count) {\n      var _this3 = this;\n      var readArray = new Array(count).fill(0);\n      return readArray.map(function (_, idx) {\n        return _this3.decoder.decode(chunk.slice(8 * idx, 8 * idx + 8));\n      });\n    }\n  }, {\n    key: \"readFieldMissingRange\",\n    value: function readFieldMissingRange(view) {\n      return [view.getFloat64(0, true), view.getFloat64(8, true)];\n    }\n  }, {\n    key: \"readFieldMissing\",\n    value: function readFieldMissing(feeder, numeric, code) {\n      var chunk = feeder.next(8 * Math.abs(code));\n      var view = new DataView(chunk);\n      return {\n        codes: numeric && code > 0 ? this.readFieldMissingCodes(view, code) : numeric && code === -3 ? this.readFieldMissingCodes(view, 3).slice(2) : [],\n        range: numeric && code < 0 ? this.readFieldMissingRange(view) : [undefined, undefined],\n        strings: !numeric && code > 0 ? this.readFieldMissingStrings(chunk, code) : []\n      };\n    }\n  }, {\n    key: \"readField\",\n    value: function readField(feeder) {\n      this.log.push('Reading Field at ' + feeder.position());\n      var start = feeder.position();\n      var chunk = feeder.next(28);\n      var view = new DataView(chunk);\n      var code = view.getInt32(0, true);\n      var labeled = view.getInt32(4, true);\n      var missings = view.getInt32(8, true);\n      var name = this.decoder.decode(chunk.slice(20, 28)).trim();\n      var label = labeled ? this.readFieldLabel(feeder) : '';\n      var missing = missings ? this.readFieldMissing(feeder, code === 0, missings) : {\n        codes: [],\n        range: [undefined, undefined],\n        strings: []\n      };\n      return {\n        start: start,\n        code: code,\n        name: name,\n        label: label,\n        missing: missing,\n        trailers: 0\n      };\n    }\n  }, {\n    key: \"getLevel\",\n    value: function getLevel(feeder) {\n      this.log.push('Scale level at ' + feeder.position());\n      var view = new DataView(feeder.next(9));\n      var length = view.getInt8(8);\n      var size = (length + 1) % 8 ? length + (8 - (length + 1) % 8) : length;\n      return [view.getFloat64(0, true), this.decoder.decode(feeder.next(size)).substring(0, length).trim()];\n    }\n  }, {\n    key: \"readScale\",\n    value: function readScale(feeder) {\n      var _this4 = this;\n      this.log.push('Scale definition at ' + feeder.position());\n      var count = new DataView(feeder.next(4)).getInt32(0, true);\n      var readArray = new Array(count).fill(0);\n      var levels = new Map(readArray.map(function () {\n        return _this4.getLevel(feeder);\n      }));\n      var view = new DataView(feeder.next(8));\n      var magic = view.getInt32(0, true);\n      var icount = view.getInt32(4, true);\n      if (magic !== 4) {\n        throw new Error('Levels read error. ' + 'Magic value Expected: 4 ' + 'Actual: ' + magic);\n      }\n      var iview = new DataView(feeder.next(4 * icount));\n      var indices = new Set(new Array(icount).fill(0).map(function (_, idx) {\n        return iview.getInt32(idx * 4, true);\n      }));\n      return {\n        map: levels,\n        indices: indices\n      };\n    }\n  }, {\n    key: \"readDocument\",\n    value: function readDocument(feeder) {\n      var _this5 = this;\n      this.log.push('Sys Document at ' + feeder.position());\n      var count = new DataView(feeder.next(4)).getInt32(0, true);\n      var chunk = feeder.next(count * 80);\n      var docArray = new Array(count).fill(0);\n      return docArray.map(function (_, idx) {\n        return _this5.decoder.decode(chunk.slice(idx * 80, idx * 80 + 80));\n      });\n    }\n  }, {\n    key: \"readSysInteger\",\n    value: function readSysInteger(feeder) {\n      this.log.push('Sys Integer at ' + feeder.position());\n      var view = new DataView(feeder.next(32));\n      return {\n        major: view.getInt32(0, true),\n        minor: view.getInt32(4, true),\n        revision: view.getInt32(8, true),\n        machine: view.getInt32(12, true),\n        \"float\": view.getInt32(16, true),\n        compression: view.getInt32(20, true),\n        endianness: view.getInt32(24, true),\n        character: view.getInt32(28, true)\n      };\n    }\n  }, {\n    key: \"readSysFloat\",\n    value: function readSysFloat(feeder) {\n      this.log.push('Sys Float at ' + feeder.position());\n      var view = new DataView(feeder.next(24));\n      return {\n        missing: view.getFloat64(0, true),\n        high: view.getFloat64(8, true),\n        low: view.getFloat64(16, true)\n      };\n    }\n  }, {\n    key: \"readSysDisplay\",\n    value: function readSysDisplay(feeder, count) {\n      this.log.push('Sys Display at ' + feeder.position());\n      var view = new DataView(feeder.next(count * 12));\n      var dispArray = new Array(count).fill(0);\n      return dispArray.map(function (_, idx) {\n        return {\n          type: view.getInt32(idx * 12, true),\n          width: view.getInt32(idx * 12 + 4, true),\n          align: view.getInt32(idx * 12 + 8, true)\n        };\n      });\n    }\n  }, {\n    key: \"readNames\",\n    value: function readNames(feeder, size) {\n      this.log.push('Names at ' + feeder.position());\n      var raw = this.decoder.decode(feeder.next(size));\n      return new Map(raw.split('\\t').map(function (str) {\n        return str.split('=');\n      }));\n    }\n  }, {\n    key: \"readLongWidths\",\n    value: function readLongWidths(feeder, size) {\n      this.log.push('Long Widths at ' + feeder.position());\n      var raw = this.decoder.decode(feeder.next(size));\n      var rows = raw.split('\\t');\n      return new Map(rows.slice(0, rows.length - 1).map(function (str) {\n        return str.split('=');\n      }).map(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n          name = _ref2[0],\n          length = _ref2[1];\n        return [name, parseInt(length, 10)];\n      }));\n    }\n  }, {\n    key: \"readLongNames\",\n    value: function readLongNames(feeder, size) {\n      this.log.push('Long Names at ' + feeder.position());\n      // need to figure out how this works\n      return feeder.next(size);\n    }\n  }, {\n    key: \"readUnrecognized\",\n    value: function readUnrecognized(feeder, count, length) {\n      var chunk = feeder.next(count * length);\n      var readArray = new Array(count).fill(0);\n      return readArray.map(function (_, idx) {\n        return chunk.slice(idx * length, idx * length + length);\n      });\n    }\n  }, {\n    key: \"readInternal\",\n    value: function readInternal(feeder) {\n      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n      this.log.push('Reading Internal');\n      var partial = {};\n      var code;\n      var subcode;\n      var subview;\n      var length;\n      var count;\n      while (!partial.finished) {\n        code = new DataView(feeder.next(4)).getInt32(0, true);\n        switch (code) {\n          case 3:\n            partial.levels = ((_a = partial.levels) !== null && _a !== void 0 ? _a : []).concat(this.readScale(feeder));\n            break;\n          case 6:\n            partial.documents = ((_b = partial.documents) !== null && _b !== void 0 ? _b : []).concat(this.readDocument(feeder));\n            break;\n          case 7:\n            subview = new DataView(feeder.next(12));\n            subcode = subview.getInt32(0, true);\n            length = subview.getInt32(4, true);\n            count = subview.getInt32(8, true);\n            switch (subcode) {\n              case 3:\n                this.log.push('Subcode 3');\n                if (length * count !== 32) {\n                  throw new Error('Special code 3 ' + 'Expected: 32 bytes; ' + 'Actual: ' + length * count);\n                }\n                partial.integer = this.readSysInteger(feeder);\n                break;\n              case 4:\n                this.log.push('Subcode 4');\n                if (length * count !== 24) {\n                  throw new Error('Special code 4 ' + 'Expected: 24 bytes; ' + 'Actual: ' + length * count);\n                }\n                partial[\"float\"] = this.readSysFloat(feeder);\n                break;\n              case 11:\n                this.log.push('Subcode 11');\n                if (length !== 4) {\n                  throw new Error('Special code 11 ' + 'Expected: 4 bytes; ' + 'Actual: ' + length);\n                }\n                if (count % 3) {\n                  throw new Error('Special code 11 ' + 'Expected: Length factor of 3; ' + 'Actual: ' + length);\n                }\n                partial.display = ((_c = partial.display) !== null && _c !== void 0 ? _c : []).concat(this.readSysDisplay(feeder, count / 3));\n                break;\n              case 13:\n                this.log.push('Subcode 13');\n                partial.names = new Map([].concat(_toConsumableArray((_d = partial.names) !== null && _d !== void 0 ? _d : []), _toConsumableArray(this.readNames(feeder, count * length))));\n                break;\n              case 14:\n                this.log.push('Subcode 14');\n                partial.longs = new Map([].concat(_toConsumableArray((_e = partial.longs) !== null && _e !== void 0 ? _e : []), _toConsumableArray(this.readLongWidths(feeder, count * length))));\n                break;\n              case 21:\n                this.log.push('Subcode 21');\n                partial.extra = ((_f = partial.extra) !== null && _f !== void 0 ? _f : []).concat(this.readLongNames(feeder, count * length));\n                break;\n              default:\n                this.log.push('Unrecognized Subcode');\n                partial.unrecognized = ((_g = partial.unrecognized) !== null && _g !== void 0 ? _g : []).concat([[subcode, this.readUnrecognized(feeder, count, length)]]);\n                break;\n            }\n            break;\n          case 999:\n            feeder.next(4);\n            partial.finished = feeder.position();\n            break;\n          default:\n            throw new Error('Internal Code Expected : [3, 6, 7, 999]; Actual : ' + code);\n        }\n      }\n      return {\n        \"float\": (_h = partial[\"float\"]) !== null && _h !== void 0 ? _h : {\n          missing: undefined,\n          high: undefined,\n          low: undefined\n        },\n        integer: (_j = partial.integer) !== null && _j !== void 0 ? _j : {\n          major: undefined,\n          minor: undefined,\n          revision: undefined,\n          machine: undefined,\n          \"float\": undefined,\n          compression: undefined,\n          endianness: undefined,\n          character: undefined\n        },\n        display: (_k = partial.display) !== null && _k !== void 0 ? _k : [],\n        documents: (_l = partial.documents) !== null && _l !== void 0 ? _l : [],\n        names: (_m = partial.names) !== null && _m !== void 0 ? _m : new Map(),\n        longs: (_o = partial.longs) !== null && _o !== void 0 ? _o : new Map(),\n        levels: (_p = partial.levels) !== null && _p !== void 0 ? _p : [],\n        extra: (_q = partial.extra) !== null && _q !== void 0 ? _q : [],\n        unrecognized: (_r = partial.unrecognized) !== null && _r !== void 0 ? _r : [],\n        finished: partial.finished\n      };\n    }\n  }, {\n    key: \"readFields\",\n    value: function readFields(feeder) {\n      this.log.push('Reading Field at ' + feeder.position());\n      var code;\n      var fields = [];\n      var field;\n      while (true) {\n        code = new DataView(feeder.next(4)).getInt32(0, true);\n        if (code !== 2) {\n          feeder.jump(feeder.position() - 4);\n          break;\n        }\n        field = this.readField(feeder);\n        if (field.code > -1) {\n          fields.push(field);\n        } else {\n          fields[fields.length - 1].trailers++;\n        }\n      }\n      return fields;\n    }\n    /**\r\n     * Read the meta fields from a .sav file\r\n     * @param feeder A {@link Feeder} object encoding the sav file\r\n     * @remarks\r\n     * From a node.js {@link Buffer} using `fs.readFile`\r\n     * ```\r\n     * fs = require('fs');\r\n     *\r\n     * let meta;\r\n     * const parser = new SavParser()\r\n     * // with async readFile\r\n     * fs.readFile('some/path/to/file.sav', (err, data) => {\r\n     *     parser.meta(new Feeder(data.buffer)).then(\r\n     *         result => meta = result\r\n     *     )\r\n     * });\r\n     * // with syncronous readFileSync\r\n     * parser.meta(\r\n     *     new Feeder(fs.readFileSync('/some/path/to/file.sav').buffer)\r\n     * ).then(\r\n     *     parsed => meta = parsed\r\n     * );\r\n     * ```\r\n     *\r\n     * In the browser with a File API\r\n     * ```\r\n     *     <input type=\"file\" onchange = \"onChange(event)\"></input>\r\n     * ```\r\n     * ```\r\n     * const meta;\r\n     * function onChange(event){\r\n     *     const file = event.target.files[0];\r\n     *     const reader = new FileReader();\r\n     *     const parser = new SavParser();\r\n     *     reader.onload = function(data){\r\n     *         data.arrayBuffer().then(\r\n     *             buffer => parser.meta(new Feeder(buffer))\r\n     *         ).then(\r\n     *             parsed => meta = parsed\r\n     *         );\r\n     *     }\r\n     *     reader.readAsArrayBuffer(file);\r\n     * }\r\n     * ```\r\n     * @return A promise resolving with a {@link Meta} object\r\n     */\n  }, {\n    key: \"meta\",\n    value: function meta(feeder) {\n      var _this6 = this;\n      this.log.splice(0, this.log.length);\n      var position = feeder.position();\n      feeder.jump(0);\n      return new Promise(function (resolve, reject) {\n        var chunk = feeder.next(176);\n        var view = new DataView(chunk);\n        var magic = _this6.decoder.decode(chunk.slice(0, 4));\n        if (magic !== '$FL2') {\n          reject(new Error('File is not a sav. ' + 'Magic key Expected: \"$FL2\"; ' + 'Actual: ' + magic));\n        }\n        resolve({\n          product: _this6.decoder.decode(chunk.slice(4, 64)).trim(),\n          layout: view.getInt32(64, true),\n          variables: view.getInt32(68, true),\n          compression: view.getInt32(72, true),\n          weightIndex: view.getInt32(76, true),\n          cases: view.getInt32(80, true),\n          bias: view.getFloat64(84, true),\n          createdDate: _this6.decoder.decode(chunk.slice(92, 101)),\n          createdTime: _this6.decoder.decode(chunk.slice(101, 109)),\n          label: _this6.decoder.decode(chunk.slice(109, 173)).trim()\n        });\n      })[\"finally\"](function () {\n        return feeder.jump(position);\n      });\n    }\n    /**\r\n     * Read the column header fields from a .sav file.\r\n     * Header here refers to the head of the columns of the data, i.e.\r\n     * properties of the variables in the data file\r\n     * @param feeder A {@link Feeder} object encoding the sav file\r\n     * @remarks\r\n     * From a node.js {@link Buffer} using `fs.readFile`\r\n     * ```\r\n     * fs = require('fs');\r\n     *\r\n     * let headers;\r\n     * const parser = new SavParser()\r\n     * // with async readFile\r\n     * fs.readFile('some/path/to/file.sav', (err, data) => {\r\n     *     parser.headers(new Feeder(data.buffer)).then(\r\n     *         result => headers = result\r\n     *     )\r\n     * });\r\n     * // with syncronous readFileSync\r\n     * parser.headers(\r\n     *     new Feeder(fs.readFileSync('/some/path/to/file.sav').buffer)\r\n     * ).then(\r\n     *     parsed => headers = parsed\r\n     * );\r\n     * ```\r\n     *\r\n     * In the browser with a File API\r\n     * ```\r\n     *     <input type=\"file\" onchange = \"onChange(event)\"></input>\r\n     * ```\r\n     * ```\r\n     * const headers;\r\n     * function onChange(event){\r\n     *     const file = event.target.files[0];\r\n     *     const reader = new FileReader();\r\n     *     const parser = new SavParser();\r\n     *     reader.onload = function(data){\r\n     *         data.arrayBuffer().then(\r\n     *             buffer => parser.headers(new Feeder(buffer))\r\n     *         ).then(\r\n     *             parsed => headers = parsed\r\n     *         );\r\n     *     }\r\n     *     reader.readAsArrayBuffer(file);\r\n     * }\r\n     * ```\r\n     * @return A promise resolving with an Array<{@link Meta}> object\r\n     */\n  }, {\n    key: \"headers\",\n    value: function headers(feeder) {\n      this.log.splice(0, this.log.length);\n      var position = feeder.position();\n      feeder.jump(176);\n      return Promise.resolve(this.readFields(feeder))[\"finally\"](function () {\n        return feeder.jump(position);\n      });\n    }\n    /**\r\n     * Read all schema fields from a .sav file.\r\n     * Schema here refers to all information except for the data cells themselves\r\n     * @param feeder A {@link Feeder} object encoding the sav file\r\n     * @remarks\r\n     * From a node.js {@link Buffer} using `fs.readFile`\r\n     * ```\r\n     * fs = require('fs');\r\n     *\r\n     * let schema;\r\n     * const parser = new SavParser()\r\n     * // with async readFile\r\n     * fs.readFile('some/path/to/file.sav', (err, data) => {\r\n     *     parser.schema(new Feeder(data.buffer)).then(\r\n     *         result => schema = result\r\n     *     )\r\n     * });\r\n     * // with syncronous readFileSync\r\n     * parser.schema(\r\n     *     new Feeder(fs.readFileSync('/some/path/to/file.sav').buffer)\r\n     * ).then(\r\n     *     parsed => schema = parsed\r\n     * );\r\n     * ```\r\n     *\r\n     * In the browser with a File API\r\n     * ```\r\n     *     <input type=\"file\" onchange = \"onChange(event)\"></input>\r\n     * ```\r\n     * ```\r\n     * const schema;\r\n     * function onChange(event){\r\n     *     const file = event.target.files[0];\r\n     *     const reader = new FileReader();\r\n     *     const parser = new SavParser();\r\n     *     reader.onload = function(data){\r\n     *         data.arrayBuffer().then(\r\n     *             buffer => parser.schema(new Feeder(buffer))\r\n     *         ).then(\r\n     *             parsed => schema = parsed\r\n     *         );\r\n     *     }\r\n     *     reader.readAsArrayBuffer(file);\r\n     * }\r\n     * ```\r\n     * @return A promise resolving with an {@link Schema} object\r\n     */\n  }, {\n    key: \"schema\",\n    value: function schema(feeder) {\n      var _this7 = this;\n      this.log.splice(0, this.log.length);\n      var position = feeder.position();\n      return this.meta(feeder).then(function (meta) {\n        return {\n          meta: meta\n        };\n      }).then(function (partial) {\n        feeder.jump(176);\n        return _objectSpread(_objectSpread({}, partial), {}, {\n          headers: _this7.readFields(feeder)\n        });\n      }).then(function (partial) {\n        return _objectSpread(_objectSpread({}, partial), {}, {\n          internal: _this7.readInternal(feeder)\n        });\n      })[\"finally\"](function () {\n        return feeder.jump(position);\n      });\n    }\n    /**\r\n     * Read all fields from a .sav file.\r\n     * All fields include the full {@link Schema} and all data cells as an\r\n     * Array<{@link Row}.\r\n     * @param feeder A {@link Feeder} object encoding the sav file\r\n     * @remarks\r\n     * From a node.js {@link Buffer} using `fs.readFile`\r\n     * ```\r\n     * fs = require('fs');\r\n     *\r\n     * let all;\r\n     * const parser = new SavParser()\r\n     * // with async readFile\r\n     * fs.readFile('some/path/to/file.sav', (err, data) => {\r\n     *     parser.all(new Feeder(data.buffer)).then(\r\n     *         result => all = result\r\n     *     )\r\n     * });\r\n     * // with syncronous readFileSync\r\n     * parser.all(\r\n     *     new Feeder(fs.readFileSync('/some/path/to/file.sav').buffer)\r\n     * ).then(\r\n     *     parsed => all = parsed\r\n     * );\r\n     * ```\r\n     *\r\n     * In the browser with a File API\r\n     * ```\r\n     *     <input type=\"file\" onchange = \"onChange(event)\"></input>\r\n     * ```\r\n     * ```\r\n     * const all;\r\n     * function onChange(event){\r\n     *     const file = event.target.files[0];\r\n     *     const reader = new FileReader();\r\n     *     const parser = new SavParser();\r\n     *     reader.onload = function(data){\r\n     *         data.arrayBuffer().then(\r\n     *             buffer => parser.all(new Feeder(buffer))\r\n     *         ).then(\r\n     *             parsed => all = parsed\r\n     *         );\r\n     *     }\r\n     *     reader.readAsArrayBuffer(file);\r\n     * }\r\n     * ```\r\n     * @return A promise resolving with an {@link Parsed} object\r\n     */\n  }, {\n    key: \"all\",\n    value: function all(feeder) {\n      var _this8 = this;\n      this.log.splice(0, this.log.length);\n      var position = feeder.position();\n      return this.schema(feeder).then(function (schema) {\n        return _objectSpread(_objectSpread({}, schema), {}, {\n          rows: new DataReader(schema, feeder, _this8.log).read()\n        });\n      })[\"finally\"](function () {\n        return feeder.jump(position);\n      });\n    }\n  }]);\n  return SavParser;\n}();\nexports.SavParser = SavParser;\nvar dataset_1 = require(\"./dataset\");\nObject.defineProperty(exports, \"Savvy\", {\n  enumerable: true,\n  get: function get() {\n    return dataset_1.Savvy;\n  }\n});"],"names":[],"sourceRoot":""}